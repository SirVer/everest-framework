mod generated {

#![allow(clippy::let_unit_value, clippy::useless_conversion, clippy::match_single_binding, dead_code, unused_mut, unused_variables)]

pub mod types {
{% include "type_module" %}
}

{% for p_config in provided_config %}
/// The configuration for the {{ p_config.name }}.
#[derive(Debug)]
pub(crate) struct {{ p_config.name | title }}Config {
    {% for config in p_config.config %}
    /// {{ config.description }}
    pub(crate) {{ config.name }}: {{ config.data_type }},
    {% endfor %}
}
{% endfor %}

/// The configuration for the module. It also contains the config for all other
/// interfaces.
#[derive(Debug)]
pub(crate) struct ModuleConfig {
    {% for config in module_config %}
    /// {{ config.description }}
    pub(crate) {{ config.name }}: {{ config.data_type }},
    {% endfor %}

    {% for p_config in provided_config %}
    /// The config for the `{{ p_config.name }}` interface.
    pub(crate) {{ p_config.name }}_config: {{ p_config.name | title }}Config,
    {% endfor %}
}

/// Returns the config for the whole module. You can call this function at any
/// time in your code.
pub(crate) fn get_config() -> ModuleConfig {
    let raw_config = everestrs::get_module_configs();

    {% for p_config in provided_config %}
    let {{ p_config.name }}_config = {{ p_config.name | title }}Config {
        {% for config in p_config.config %}
        {{ config.name }}: raw_config.get("{{ p_config.name }}").unwrap().get("{{ config.name }}").unwrap().try_into().unwrap(),
        {% endfor %} 
    };
    {% endfor %}
    ModuleConfig {
    {% for config in module_config %}
    {{ config.name }}: raw_config.get("!module").unwrap().get("{{ config.name }}").unwrap().try_into().unwrap(),
    {% endfor %}

    {% for p_config in provided_config %}
    {{ p_config.name }}_config,
    {% endfor %}
    }
}

/// Called when the module receives on_ready from EVerest.
pub(crate) trait OnReadySubscriber: Sync + Send {
    fn on_ready(&self, pub_impl: &ModulePublisher);
}

{% for trait in provided_interfaces %}
{% include "service" %}
{% endfor %}

{% for trait in required_interfaces %}
{% include "client" %}
{% endfor %}

#[derive(Clone)]
pub(crate) struct ModulePublisher {
{% for provide in provides %}
   pub(crate) {{ provide.implementation_id }}: {{provide.interface | title}}ServicePublisher,
{% endfor %}
{% for require in requires %}
   pub(crate) {{ require.implementation_id }}: {{require.interface | title}}ClientPublisher,
{% endfor %}
}

pub(crate) struct Module {
    on_ready: ::std::sync::Arc<dyn OnReadySubscriber>,
{% for provide in provides %}
   {{ provide.implementation_id }}: ::std::sync::Arc<dyn {{provide.interface | title}}ServiceSubscriber>,
{% endfor %}
{% for require in requires %}
   {{ require.implementation_id }}: ::std::sync::Arc<dyn {{require.interface | title}}ClientSubscriber>,
{% endfor %}

    publisher: ModulePublisher,
}

impl Module {
    #[must_use]
    pub(crate) fn new(
        on_ready: ::std::sync::Arc<dyn OnReadySubscriber>,
{% for provide in provides %}
        {{ provide.implementation_id }}: ::std::sync::Arc<dyn {{provide.interface | title}}ServiceSubscriber>,
{% endfor %}
{% for require in requires %}
      {{ require.implementation_id }}: ::std::sync::Arc<dyn {{require.interface | title}}ClientSubscriber>,
{% endfor %}
    ) -> ::std::sync::Arc<Self> {
        let runtime = ::everestrs::Runtime::new();
        let this = ::std::sync::Arc::new(Self {
            on_ready,
{% for provide in provides %}
            {{ provide.implementation_id }},
{% endfor %}
{% for require in requires %}
            {{ require.implementation_id }},
{% endfor %}
            publisher: ModulePublisher {
{% for provide in provides %}
   {{ provide.implementation_id }}: {{provide.interface | title}}ServicePublisher {
      implementation_id: "{{ provide.implementation_id }}",
      runtime: runtime.clone(),
      },
{% endfor %}
{% for require in requires %}
        {{ require.implementation_id }}: {{require.interface | title}}ClientPublisher {
      implementation_id: "{{ require.implementation_id }}",
      runtime: runtime.clone(),
      },
{% endfor %}
            },
        });

        runtime.as_ref().set_subscriber(::std::sync::Arc::<Module>::downgrade(&this));
        this
    }
}

impl ::everestrs::Subscriber for Module {
    fn handle_command(
        &self,
        implementation_id: &str,
        name: &str,
        parameters: ::std::collections::HashMap<String, serde_json::Value>,
    ) -> ::everestrs::Result<serde_json::Value> {
        match implementation_id {
{% for provide in provides %}
   "{{ provide.implementation_id }}" => {
   dispatch_command_to_{{ provide.interface | snake }}(&self.publisher, self.{{ provide.implementation_id }}.as_ref(), name, parameters)
},
{% endfor %}
            _ => Err(::everestrs::Error::InvalidArgument(
                "Unknown implementation_id called.",
            )),
        }
    }

    fn handle_variable(
        &self,
        implementation_id: &str,
        name: &str,
        value: serde_json::Value,
    ) -> ::everestrs::Result<()> {
        match implementation_id {
{% for req in requires %}
         "{{ req.implementation_id }}" => {
         dispatch_variable_to_{{ req.interface | snake }}(&self.publisher, self.{{ req.implementation_id }}.as_ref(), name, value)
      },
      {% endfor %}
      _ => Err(::everestrs::Error::InvalidArgument(
                  "Unknown variable received.",
              ))
        }
    }

    fn on_ready(&self) {
        self.on_ready.on_ready(&self.publisher)
    }
}

}
